# -*- coding: utf-8 -*-
"""
routes/solve.py
Endpoint principal de Tutor√≠n - ‚úÖ CORREGIDO: Normaliza decimales correctamente
"""
from typing import Optional
from fastapi import APIRouter
from pydantic import BaseModel
import uuid
from modules.ai_analyzer import analyze_prompt, run_engine_for
from logic.utils import is_unknown_answer
from logic.ai_hints.ai_router import generate_hint_with_ai
from db import get_progress, upsert_progress, save_history

router = APIRouter()

class SolveRequest(BaseModel):
    user_id: Optional[str] = None
    question: str
    last_answer: Optional[str] = ""
    exercise_id: Optional[str] = None
    context: Optional[str] = ""
    cycle: Optional[str] = "c2"

def _canon(s: str) -> str:
    """
    Normaliza texto para comparaci√≥n.
    ‚úÖ MEJORADO: Elimina ceros finales de n√∫meros decimales
    
    Ejemplos:
    - "0.04690" ‚Üí "0.0469"
    - "3.50" ‚Üí "3.5"
    - "23.00" ‚Üí "23"
    - "abc" ‚Üí "abc" (sin cambios si no es n√∫mero)
    """
    # Normalizaci√≥n b√°sica
    s = str(s or "").strip().replace(" ", "").replace(",", ".").lower()
    
    # Intentar normalizar como n√∫mero (eliminar ceros finales)
    try:
        # Si puede convertirse a float, normalizarlo
        num = float(s)
        
        # Convertir de vuelta a string sin ceros innecesarios
        # Usar :g para formato autom√°tico sin ceros finales
        s = f"{num:g}"
        
    except (ValueError, TypeError):
        # Si no es un n√∫mero v√°lido, dejar como est√°
        pass
    
    return s

@router.post("/")
def solve(req: SolveRequest):
    """Orquestador principal: gestiona paso actual, errores y motores."""
    exercise_id = req.exercise_id or str(uuid.uuid4())
    
    # Leer progreso actual
    step_now, error_count, prev_ctx = get_progress(exercise_id)
    
    # Detectar tema y motor
    nlu = analyze_prompt(req.question or "")
    engine = nlu.get("engine") or "generic_engine"
    topic = nlu.get("intent") or "general"
    
    # ---------------------------------------------------
    # 1Ô∏è‚É£ CASO "NO S√â" ‚Üí PISTA
    # ‚úÖ CORREGIDO: Primero llamamos al motor para obtener hint_type correcto
    # ---------------------------------------------------
    if is_unknown_answer(req.last_answer or ""):
        error_count = min(9, error_count + 1)
        
        # üîë CLAVE: Llamar al motor para obtener el hint_type y contexto correctos
        det = run_engine_for(
            engine,
            prompt=req.question,
            step=step_now,
            answer="",  # Sin respuesta, solo queremos el contexto
            errors=error_count,
        )
        
        if det and det.get("hint_type"):
            # Usar el hint_type real del motor
            hint_type = det.get("hint_type", "general")
            message = det.get("message", req.question)
            
            # Generar pista con el hint_type correcto
            ai_hint = generate_hint_with_ai(
                topic,
                hint_type,  # ‚úÖ hint_type correcto (ej: "decimal_multiplicar_sin_coma")
                message,    # ‚úÖ contexto completo con HTML
                answer=req.last_answer or "",
                error_count=error_count,
                cycle=req.cycle,
            )
        else:
            # Fallback si el motor no devuelve hint_type
            ai_hint = "üí° Pista: piensa paso a paso. Revisa el n√∫mero y vuelve a intentarlo."
        
        msg = ai_hint or "üß† Pista: piensa paso a paso y revisa los n√∫meros."
        new_ctx = (prev_ctx + "\n" + msg).strip()
        upsert_progress(exercise_id, step_now, error_count, new_ctx, user_id=req.user_id)
        save_history(
            req.user_id, exercise_id, req.question, req.last_answer, msg, step_now, error_count
        )
        return {
            "exercise_id": exercise_id,
            "status": "hint",
            "step": step_now,
            "error_count": error_count,
            "message": msg,
            "expected_answer": None,
            "context": new_ctx,
            "nlu": nlu,
        }

    # ---------------------------------------------------
    # 2Ô∏è‚É£ LLAMAR AL MOTOR CON EL PASO ACTUAL
    # ---------------------------------------------------
    det = run_engine_for(
        engine,
        prompt=req.question,
        step=step_now,
        answer=req.last_answer or "",
        errors=error_count,
    )
    if not det:
        return {
            "exercise_id": exercise_id,
            "status": "error",
            "message": "No pude procesar este ejercicio.",
            "nlu": nlu,
        }
    
    message = det.get("message", "")
    expected = det.get("expected_answer")
    status = det.get("status", "ask")
    next_step = int(det.get("next_step", step_now))
    hint_type = det.get("hint_type", "general_error")

    # ---------------------------------------------------
    # 3Ô∏è‚É£ CASOS DE RESPUESTA
    # ---------------------------------------------------
    
    # 3a. Primera vez en este paso (sin respuesta todav√≠a)
    if _canon(req.last_answer) == "":
        new_ctx = (prev_ctx + "\n" + message).strip()
        upsert_progress(exercise_id, step_now, error_count, new_ctx, user_id=req.user_id)
        save_history(
            req.user_id, exercise_id, req.question, req.last_answer, message, step_now, error_count
        )
        return {
            "exercise_id": exercise_id,
            "status": status,
            "step": step_now,
            "error_count": error_count,
            "message": message,
            "expected_answer": expected,
            "context": new_ctx,
            "nlu": nlu,
        }

    # 3b. HAY respuesta del usuario ‚Üí verificar
    if not expected:
        # Si el motor no espera una respuesta espec√≠fica, avanzamos directamente
        new_ctx = (prev_ctx + "\n" + message).strip()
        upsert_progress(exercise_id, next_step, 0, new_ctx, user_id=req.user_id)
        save_history(
            req.user_id, exercise_id, req.question, req.last_answer, message, next_step, 0
        )
        return {
            "exercise_id": exercise_id,
            "status": status,
            "step": next_step,
            "error_count": 0,
            "message": message,
            "expected_answer": None,
            "context": new_ctx,
            "nlu": nlu,
        }

    # 3c. Respuesta INCORRECTA ‚Üí incrementar errores, mantener paso
    if _canon(req.last_answer) != _canon(expected):
        error_count = min(9, error_count + 1)
        # Generar pista con el hint_type correcto del motor
        ai_hint = generate_hint_with_ai(
            topic,
            hint_type,  # ‚úÖ hint_type correcto
            message,    # ‚úÖ contexto completo con HTML
            answer=req.last_answer or "",
            error_count=error_count,
            cycle=req.cycle,
        )
        feedback = f"‚ùå No es exactamente. {ai_hint if ai_hint else 'Revisa e intenta de nuevo.'}"
        new_ctx = (prev_ctx + "\n" + feedback).strip()
        upsert_progress(exercise_id, step_now, error_count, new_ctx, user_id=req.user_id)
        save_history(
            req.user_id, exercise_id, req.question, req.last_answer, feedback, step_now, error_count
        )
        return {
            "exercise_id": exercise_id,
            "status": "feedback",
            "step": step_now,
            "error_count": error_count,
            "message": feedback,
            "expected_answer": expected,
            "context": new_ctx,
            "nlu": nlu,
        }

    # ---------------------------------------------------
    # 3d. Respuesta CORRECTA ‚Üí avanzar al siguiente paso
    # üîë SOLUCI√ìN: Llamar al motor de nuevo con el next_step
    # ---------------------------------------------------
    
    # ‚úÖ PASO 1: Guardar el progreso del paso actual
    new_ctx = (prev_ctx + "\n" + message).strip()
    upsert_progress(exercise_id, next_step, 0, new_ctx, user_id=req.user_id)
    save_history(
        req.user_id, exercise_id, req.question, req.last_answer, message, next_step, 0
    )
    
    # ‚úÖ PASO 2: Llamar al motor con el SIGUIENTE PASO para obtener la nueva pregunta
    det_next = run_engine_for(
        engine,
        prompt=req.question,
        step=next_step,  # üîë Llamamos con el NUEVO step
        answer="",       # Sin respuesta, queremos la pregunta del siguiente paso
        errors=0,        # Reiniciamos errores
    )
    
    if det_next:
        # Usar el mensaje del siguiente paso
        next_message = det_next.get("message", message)
        next_expected = det_next.get("expected_answer")
        next_status = det_next.get("status", status)
        
        # Actualizar contexto con el nuevo mensaje
        final_ctx = (new_ctx + "\n" + next_message).strip()
        upsert_progress(exercise_id, next_step, 0, final_ctx, user_id=req.user_id)
        
        return {
            "exercise_id": exercise_id,
            "status": next_status,
            "step": next_step,
            "error_count": 0,
            "message": next_message,  # ‚úÖ Mensaje del SIGUIENTE paso
            "expected_answer": next_expected,
            "context": final_ctx,
            "nlu": nlu,
        }
    else:
        # Fallback: devolver el mensaje original si el motor falla
        return {
            "exercise_id": exercise_id,
            "status": status,
            "step": next_step,
            "error_count": 0,
            "message": message,
            "expected_answer": det.get("expected_answer"),
            "context": new_ctx,
            "nlu": nlu,
        }